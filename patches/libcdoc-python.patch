diff --git a/libcdoc.i b/libcdoc.i
index c681964..173770d 100644
--- a/libcdoc.i
+++ b/libcdoc.i
@@ -81,6 +81,113 @@
 %ignore libcdoc::PKCS11Backend::getCertificate(std::vector<uint8_t>& val, bool& rsa, int slot, const std::vector<uint8_t>& pin, const std::vector<uint8_t>& id, const std::string& label);
 %ignore libcdoc::PKCS11Backend::getPublicKey(std::vector<uint8_t>& val, bool& rsa, int slot, const std::vector<uint8_t>& pin, const std::vector<uint8_t>& id, const std::string& label);
 
+#ifdef SWIGPYTHON
+%include <pybuffer.i>
+%include <std_vector.i>
+%include <std_string.i>
+%include <std_map.i>
+%include <exception.i>
+%include <stdint.i>
+
+// Map C++ integer types to Python
+%apply long long { int64_t }
+%apply unsigned long long { uint64_t }
+%apply int { int32_t }
+%apply unsigned int { uint32_t }
+%apply int { int16_t }
+%apply unsigned int { uint16_t }
+%apply long long { libcdoc::result_t }
+
+// Director typemaps for result_t return values
+%typemap(directorout) libcdoc::result_t {
+    $result = (libcdoc::result_t)PyLong_AsLongLong($input);
+}
+%typemap(directorin) libcdoc::result_t {
+    $input = PyLong_FromLongLong($1);
+}
+
+// Typemap for (const uint8_t *src, size_t size) - used by writeData
+%typemap(in) (const uint8_t *src, size_t size) {
+    if (PyBytes_Check($input)) {
+        $1 = (uint8_t *)PyBytes_AsString($input);
+        $2 = PyBytes_Size($input);
+    } else if (PyByteArray_Check($input)) {
+        $1 = (uint8_t *)PyByteArray_AsString($input);
+        $2 = PyByteArray_Size($input);
+    } else {
+        SWIG_exception(SWIG_TypeError, "Expected bytes or bytearray");
+    }
+}
+%typemap(typecheck, precedence=SWIG_TYPECHECK_STRING) (const uint8_t *src, size_t size) {
+    $1 = PyBytes_Check($input) || PyByteArray_Check($input);
+}
+
+// Typemap for (uint8_t *dst, size_t size) - used by readData
+%typemap(in) (uint8_t *dst, size_t size) {
+    if (PyByteArray_Check($input)) {
+        $1 = (uint8_t *)PyByteArray_AsString($input);
+        $2 = PyByteArray_Size($input);
+    } else {
+        SWIG_exception(SWIG_TypeError, "Expected bytearray");
+    }
+}
+%typemap(typecheck, precedence=SWIG_TYPECHECK_STRING) (uint8_t *dst, size_t size) {
+    $1 = PyByteArray_Check($input);
+}
+
+// Map std::vector<uint8_t> to Python bytes
+%typemap(in) std::vector<uint8_t> {
+    if (PyBytes_Check($input)) {
+        const char* data = PyBytes_AsString($input);
+        Py_ssize_t size = PyBytes_Size($input);
+        $1 = std::vector<uint8_t>(data, data + size);
+    } else if (PyByteArray_Check($input)) {
+        const char* data = PyByteArray_AsString($input);
+        Py_ssize_t size = PyByteArray_Size($input);
+        $1 = std::vector<uint8_t>(data, data + size);
+    } else {
+        SWIG_exception(SWIG_TypeError, "Expected bytes or bytearray");
+    }
+}
+
+%typemap(out) std::vector<uint8_t> {
+    $result = PyBytes_FromStringAndSize(
+        reinterpret_cast<const char*>($1.data()), $1.size());
+}
+
+// Output parameter: std::vector<uint8_t>&
+%typemap(in, numinputs=0) std::vector<uint8_t>& (std::vector<uint8_t> temp) {
+    $1 = &temp;
+}
+%typemap(argout) std::vector<uint8_t>& {
+    PyObject* bytes = PyBytes_FromStringAndSize(
+        reinterpret_cast<const char*>($1->data()), $1->size());
+    $result = SWIG_Python_AppendOutput($result, bytes, 0);
+}
+
+// Map std::vector<std::vector<uint8_t>> for certificate lists
+%template(ByteVector) std::vector<uint8_t>;
+%template(ByteVectorVector) std::vector<std::vector<uint8_t>>;
+%template(StringVector) std::vector<std::string>;
+
+// Exception handling
+%exception {
+    try {
+        $action
+    } catch (const std::exception& e) {
+        SWIG_exception(SWIG_RuntimeError, e.what());
+    }
+}
+
+// Director support for Python callbacks
+%feature("director") libcdoc::DataSource;
+%feature("director") libcdoc::CryptoBackend;
+%feature("director") libcdoc::PKCS11Backend;
+%feature("director") libcdoc::NetworkBackend;
+%feature("director") libcdoc::Configuration;
+%feature("director") libcdoc::ILogger;
+#endif
+
 #ifdef SWIGJAVA
 %include "arrays_java.i"
 %include "enums.swg"
@@ -578,5 +685,10 @@ static std::vector<unsigned char> SWIG_JavaArrayToVectorUnsignedChar(JNIEnv *jen
 %include "CDocReader.h"
 %include "CDocWriter.h"
 
+#ifdef SWIGPYTHON
+// LockVector template must come after Lock.h is included
+%template(LockVector) std::vector<libcdoc::Lock>;
+#endif
+
 #ifdef SWIGJAVA
 #endif
